Graph Problems in Java
=====================

This file provides an overview, diagrams, and Java code examples for common graph problems.

1. Graph Representation
----------------------
- Adjacency Matrix give diagram:
```
0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0
```
- Adjacency List give diagram:
```
0: 1 -> 3
1: 0 -> 2
2: 1 -> 3
3: 0 -> 2
```
- Adjacency Matrix
Java Example (Adjacency Matrix):
```java
import java.util.Arrays;
class Graph {
    private final int V;
    private final int[][] adjMatrix;

    public Graph(int V) {
        this.V = V;
        adjMatrix = new int[V][V];
    }

    public void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // For undirected graph
    }

    public boolean isEdge(int u, int v) {
        return adjMatrix[u][v] == 1;
    }

    public void printGraph() {
        for (int[] row : adjMatrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
- Adjacency List

Java Example (Adjacency List):
```
import java.util.*;
class Graph {
    private final int V;
    private final List<List<Integer>> adj;
    public Graph(int V) {
        this.V = V;
        adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());
    }
    public void addEdge(int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u); // For undirected graph
    }
    public List<Integer> getAdj(int u) { return adj.get(u); }
}
```

2. Depth-First Search (DFS)
--------------------------
Diagram:
0---1
|   |
3---2

Java Example:
```
void dfs(int v, boolean[] visited, Graph g) {
    visited[v] = true;
    System.out.print(v + " ");
    for (int u : g.getAdj(v)) {
        if (!visited[u]) dfs(u, visited, g);
    }
}
```

3. Breadth-First Search (BFS)
----------------------------
Diagram:
0---1
|   |
3---2

Java Example:
```
void bfs(int start, Graph g) {
    boolean[] visited = new boolean[g.V];
    Queue<Integer> q = new LinkedList<>();
    q.add(start);
    visited[start] = true;
    while (!q.isEmpty()) {
        int v = q.poll();
        System.out.print(v + " ");
        for (int u : g.getAdj(v)) {
            if (!visited[u]) {
                visited[u] = true;
                q.add(u);
            }
        }
    }
}
```

4. Detect Cycle in Undirected Graph (DFS)
-----------------------------------------
Java Example:
```
boolean hasCycle(int v, int parent, boolean[] visited, Graph g) {
    visited[v] = true;
    for (int u : g.getAdj(v)) {
        if (!visited[u]) {
            if (hasCycle(u, v, visited, g)) return true;
        } else if (u != parent) {
            return true;
        }
    }
    return false;
}
```

5. Shortest Path (BFS for Unweighted Graph)
-------------------------------------------
Java Example:
```
int[] shortestPath(int start, Graph g) {
    int[] dist = new int[g.V];
    Arrays.fill(dist, -1);
    Queue<Integer> q = new LinkedList<>();
    q.add(start);
    dist[start] = 0;
    while (!q.isEmpty()) {
        int v = q.poll();
        for (int u : g.getAdj(v)) {
            if (dist[u] == -1) {
                dist[u] = dist[v] + 1;
                q.add(u);
            }
        }
    }
    return dist;
}
```

6. Dijkstra's Algorithm (Shortest Path in Weighted Graph)
---------------------------------------------------------
Java Example:
```
class Edge { int to, weight; Edge(int t, int w) { to = t; weight = w; } }
class WeightedGraph {
    int V;
    List<List<Edge>> adj;
    WeightedGraph(int V) {
        this.V = V;
        adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());
    }
    void addEdge(int u, int v, int w) { adj.get(u).add(new Edge(v, w)); }
}
int[] dijkstra(int src, WeightedGraph g) {
    int[] dist = new int[g.V];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[src] = 0;
    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
    pq.add(new int[]{src, 0});
    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int u = curr[0], d = curr[1];
        if (d > dist[u]) continue;
        for (Edge e : g.adj.get(u)) {
            if (dist[e.to] > dist[u] + e.weight) {
                dist[e.to] = dist[u] + e.weight;
                pq.add(new int[]{e.to, dist[e.to]});
            }
        }
    }
    return dist;
}
```
//minimum spanning tree (MST) using Prim's or Kruskal's algorithm can also be implemented similarly.
//MST Example (Kruskal's Algorithm):
```
import java.util.*;
class Edge implements Comparable<Edge> {
    int u, v, weight;
    Edge(int u, int v, int weight) {
        this.u = u; this.v = v; this.weight = weight;
    }
    public int compareTo(Edge other) {
        return Integer.compare(this.weight, other.weight);
    }
}
class KruskalMST {
    int V;
    List<Edge> edges;
    KruskalMST(int V) {
        this.V = V;
        edges = new ArrayList<>();
    }
    void addEdge(int u, int v, int weight) {
        edges.add(new Edge(u, v, weight));
    }
    int find(int[] parent, int u) {
        if (parent[u] != u) parent[u] = find(parent, parent[u]);
        return parent[u];
    }
    void union(int[] parent, int[] rank, int u, int v) {
        int rootU = find(parent, u);
        int rootV = find(parent, v);
        if (rootU != rootV) {
            if (rank[rootU] < rank[rootV]) {
                parent[rootU] = rootV;
            } else if (rank[rootU] > rank[rootV]) {
                parent[rootV] = rootU;
            } else {
                parent[rootV] = rootU;
                rank[rootU]++;
            }
        }
    }
    List<Edge> kruskal() {
        Collections.sort(edges);
        List<Edge> mst = new ArrayList<>();
        int[] parent = new int[V];
        int[] rank = new int[V];
        for (int i = 0; i < V; i++) { parent[i] = i; rank[i] = 0; }
        for (Edge e : edges) {
            if (find(parent, e.u) != find(parent, e.v)) {
                mst.add(e);
                union(parent, rank, e.u, e.v);
            }
        }
        return mst;
    }
}
```
// Example usage of Kruskal's algorithm
```
KruskalMST graph = new KruskalMST(5);
graph.addEdge(0, 1, 10);
graph.addEdge(0, 2, 6);
graph.addEdge(0, 3, 5);
graph.addEdge(1, 3, 15);
graph.addEdge(2, 3, 4);
List<Edge> mst = graph.kruskal();
for (Edge e : mst) {
    System.out.println("Edge: " + e.u + " - " + e.v + " Weight: " + e.weight);
}
// This will output the edges included in the Minimum Spanning Tree.
// Note: The above code snippets are simplified for clarity. In production code,
// you would typically include error handling, input validation, and possibly more complex data structures.
// Additional Graph Problems
//using Prim's algorithm for Minimum Spanning Tree (MST):
```
// Prim's Algorithm Example:
```
import java.util.*;
class PrimMST {
    int V;
    List<List<Edge>> adj;
    PrimMST(int V) {
        this.V = V;
        adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());
    }
    void addEdge(int u, int v, int weight) {
        adj.get(u).add(new Edge(v, weight));
        adj.get(v).add(new Edge(u, weight)); // For undirected graph
    }
    List<Edge> prim() {
        boolean[] inMST = new boolean[V];
        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));
        List<Edge> mst = new ArrayList<>();
        pq.add(new Edge(0, 0)); // Start from vertex 0
        while (!pq.isEmpty()) {
            Edge e = pq.poll();
            if (inMST[e.to]) continue;
            inMST[e.to] = true;
            mst.add(e);
            for (Edge next : adj.get(e.to)) {
                if (!inMST[next.to]) {
                    pq.add(next);
                }
            }
        }
        return mst;
    }
}
```
```
// Example usage of Prim's algorithm
PrimMST graph = new PrimMST(5);
graph.addEdge(0, 1, 10);
graph.addEdge(0, 2, 6);
graph.addEdge(0, 3, 5);
graph.addEdge(1, 3, 15);
graph.addEdge(2, 3, 4);
List<Edge> mst = graph.prim();
for (Edge e : mst) {
    System.out.println("Edge: " + e.u + " - " + e.to + " Weight: " + e.weight);
}
// This will output the edges included in the Minimum Spanning Tree using Prim's algorithm.
// Additional Graph Problems
// You can implement other graph problems such as:
//give digram and code examples for: MST
// - Topological Sort	

(You can request more graph problems: Topological Sort, Connected Components, Minimum Spanning Tree, etc.)
